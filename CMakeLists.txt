# include some defines automatically made by qpm
include(qpm_defines.cmake)

# override mod id
set(MOD_ID "bl")

# Enable link time optimization
# In my experience, this can be highly unstable but it nets a huge size optimization and likely performance
# However, the instability was seen using Android.mk/ndk-build builds. With Ninja + CMake, this problem seems to have been solved.
# As always, test thoroughly
# - Fern
# set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)

cmake_minimum_required(VERSION 3.21)
project(${COMPILE_ID})

# c++ standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED 20)

# define that stores the actual source directory
set(SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/src)
set(INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/include)

# compile options used
add_compile_options(-frtti -fexceptions)
add_compile_options(-O3)
# compile definitions used
add_compile_definitions(VERSION=\"${MOD_VERSION}\")
add_compile_definitions(ID=\"${MOD_ID}\")
add_compile_definitions(MOD_ID=\"${MOD_ID}\")
add_compile_definitions(USE_CODEGEN_FIELDS)

# recursively get all src files
RECURSE_FILES(cpp_file_list ${SOURCE_DIR}/*.cpp)
RECURSE_FILES(c_file_list ${SOURCE_DIR}/*.c)

# add all src files to compile
add_library(
        ${COMPILE_ID}
        SHARED
        ${cpp_file_list}
        ${c_file_list}
)

target_include_directories(${COMPILE_ID} PRIVATE .)

target_include_directories(${COMPILE_ID} PRIVATE extern/includes/questui_components)

# add src dir as include dir
target_include_directories(${COMPILE_ID} PRIVATE ${SOURCE_DIR})
# add include dir as include dir
target_include_directories(${COMPILE_ID} PRIVATE ${INCLUDE_DIR})
# add shared dir as include dir
target_include_directories(${COMPILE_ID} PUBLIC ${SHARED_DIR})
# codegen includes 
target_include_directories(${COMPILE_ID} PRIVATE ${EXTERN_DIR}/includes/${CODEGEN_ID}/include)

target_link_libraries(${COMPILE_ID} PRIVATE -llog -lz)
# add extern stuff like libs and other includes
include(extern.cmake)

add_custom_command(TARGET ${COMPILE_ID} POST_BUILD
        COMMAND ${CMAKE_STRIP} -d --strip-all
        "lib${COMPILE_ID}.so" -o "stripped_lib${COMPILE_ID}.so"
        COMMENT "Strip debug symbols done on final binary.")

add_custom_command(TARGET ${COMPILE_ID} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E make_directory debug
        COMMENT "Make directory for debug symbols"
        )

add_custom_command(TARGET ${COMPILE_ID} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E rename lib${COMPILE_ID}.so debug/lib${COMPILE_ID}.so
        COMMENT "Rename the lib to debug_ since it has debug symbols"
        )

add_custom_command(TARGET ${COMPILE_ID} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E rename stripped_lib${COMPILE_ID}.so lib${COMPILE_ID}.so
        COMMENT "Rename the stripped lib to regular"
        )

###
### Laurie's fully™️-functional objcopy cmake script
###

# Directory where our arbitrary asset files are stored
set(ASSETS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/assets)
# Directory to save the object files generated by llvm-objcopy
set(ASSET_BINARIES_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/binaryAssets)
set(ASSET_HEADER_PATH "${CMAKE_CURRENT_SOURCE_DIR}/include/assets.hpp")

# Define a macro which we will use for defining the symbols to access our asset files below
set(ASSET_HEADER_DATA "#define DECLARE_FILE(name, prefix) extern \"C\" uint8_t _binary_##name##_start[]; extern \"C\" uint8_t _binary_##name##_end[]; struct prefix##name { static size_t getLength() { return _binary_##name##_end - _binary_##name##_start; } static uint8_t* getData() { return _binary_##name##_start; } };\n")
file(MAKE_DIRECTORY ${ASSETS_DIRECTORY})
file(MAKE_DIRECTORY ${ASSET_BINARIES_DIRECTORY})
file(GLOB ASSETS ${ASSETS_DIRECTORY}/*.*)

# Iterate through each file in the assets directory. TODO: This could be recursive
foreach(FILE IN LISTS ASSETS)
    get_filename_component(ASSET ${FILE} NAME) # Find the asset's file name
    set(OUTPUT_FILE "${ASSET_BINARIES_DIRECTORY}/${ASSET}.o") # Save our asset in the asset binaries directory

    # Use llvm-objcopy to create an object file that stores our binary asset
    # The resulting file contains 3 symbols: _binary_<file_name>_start, _binary_<file_name>_size and _binary_<file_name>_end
    # We only use the first two
    add_custom_command(
            OUTPUT ${OUTPUT_FILE}
            COMMAND ${CMAKE_OBJCOPY} ${ASSET} ${OUTPUT_FILE} --input-target binary --output-target elf64-aarch64
            DEPENDS ${ASSETS_DIRECTORY}/${ASSET}
            WORKING_DIRECTORY ${ASSETS_DIRECTORY}
    )
    list(APPEND BINARY_ASSET_FILES ${OUTPUT_FILE})

    # Find the correct objcopy symbol name, this is always the file name with any non-alphanumeric characters replaced with _
    string(REGEX REPLACE "[^a-zA-Z0-9]" "_" FIXED_ASSET ${ASSET})
    # Add to our assets header
    set(ASSET_HEADER_DATA "${ASSET_HEADER_DATA}DECLARE_FILE(${FIXED_ASSET},)\n")
endforeach()
# Generate the assets header file
file(GENERATE OUTPUT ${ASSET_HEADER_PATH} CONTENT "${ASSET_HEADER_DATA}")

# Add our assets files to the final SO
add_library(asset_files OBJECT ${BINARY_ASSET_FILES})
set_target_properties(asset_files PROPERTIES LINKER_LANGUAGE CXX)
target_link_libraries(${COMPILE_ID} PRIVATE asset_files ${BINARY_ASSET_FILES})